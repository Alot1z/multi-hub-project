/**
 * Platform Auto Updater Service
 * Automatically updates platform.txt when new programs are added
 * Integrates with git-mcp for seamless updates
 */

export interface PlatformEntry {
  id: string
  name: string
  url: string
  type: 'hub-ui' | 'ipa-builder' | 'printer-builder' | 'game-builder' | 'ai-models' | 'custom'
  description: string
  status: 'active' | 'beta' | 'maintenance' | 'deprecated'
  features: string[]
  lastUpdated: number
  autoGenerated: boolean
}

export interface PlatformConfig {
  version: string
  baseUrl: string
  fallbackUrl: string
  entries: PlatformEntry[]
  metadata: {
    totalEntries: number
    lastUpdate: number
    autoUpdateEnabled: boolean
    gitMcpEnabled: boolean
  }
}

export interface AutoUpdateConfig {
  enableGitMcp: boolean
  enableAutoCommit: boolean
  enableAutoDeployment: boolean
  watchDirectories: string[]
  updateInterval: number
  freetierOptimized: boolean
}

export class PlatformAutoUpdaterService {
  private config: AutoUpdateConfig
  private platformConfig: PlatformConfig | null = null
  private watchedFiles: Set<string> = new Set()
  private updateQueue: PlatformEntry[] = []
  private isInitialized = false
  private updateTimer: NodeJS.Timeout | null = null

  constructor(config: Partial<AutoUpdateConfig> = {}) {
    this.config = {
      enableGitMcp: true,
      enableAutoCommit: true,
      enableAutoDeployment: true,
      watchDirectories: [
        'hub-ui/src',
        'ipa-builder/src', 
        'printer-builder/src',
        'game-builder/src',
        'ai-models/src'
      ],
      updateInterval: 30000, // 30 seconds
      freetierOptimized: true,
      ...config
    }
  }

  /**
   * Initialize the auto updater service
   */
  async initialize(): Promise<void> {
    if (this.isInitialized) return

    try {
      // Load current platform configuration
      await this.loadPlatformConfig()

      // Setup file watching
      if (this.config.enableGitMcp) {
        await this.setupFileWatching()
      }

      // Start update timer
      this.startUpdateTimer()

      this.isInitialized = true
      console.log('Platform Auto Updater initialized')

    } catch (error) {
      console.error('Failed to initialize Platform Auto Updater:', error)
      throw error
    }
  }

  /**
   * Add new program to platform automatically
   */
  async addProgram(entry: Omit<PlatformEntry, 'id' | 'lastUpdated' | 'autoGenerated'>): Promise<void> {
    await this.initialize()

    const newEntry: PlatformEntry = {
      ...entry,
      id: this.generateEntryId(entry.name),
      lastUpdated: Date.now(),
      autoGenerated: true
    }

    // Add to queue for batch processing
    this.updateQueue.push(newEntry)

    // Process immediately if not in batch mode
    if (!this.config.freetierOptimized) {
      await this.processUpdateQueue()
    }

    console.log(`Added program to platform: ${entry.name}`)
  }

  /**
   * Auto-detect new programs in directories
   */
  async scanForNewPrograms(): Promise<PlatformEntry[]> {
    const newPrograms: PlatformEntry[] = []

    try {
      for (const directory of this.config.watchDirectories) {
        const programs = await this.scanDirectory(directory)
        newPrograms.push(...programs)
      }

      // Filter out existing programs
      const existingIds = new Set(this.platformConfig?.entries.map(e => e.id) || [])
      const uniquePrograms = newPrograms.filter(p => !existingIds.has(p.id))

      return uniquePrograms

    } catch (error) {
      console.error('Failed to scan for new programs:', error)
      return []
    }
  }

  /**
   * Update platform.txt file automatically
   */
  async updatePlatformFile(): Promise<void> {
    if (!this.platformConfig) return

    try {
      // Generate new platform.txt content
      const platformContent = this.generatePlatformContent()

      // Update using git-mcp if enabled
      if (this.config.enableGitMcp) {
        await this.updateFileWithGitMcp('platform.txt', platformContent)
        
        if (this.config.enableAutoCommit) {
          await this.commitChanges('Auto-update platform.txt with new programs')
        }

        if (this.config.enableAutoDeployment) {
          await this.triggerDeployment()
        }
      }

      console.log('Platform file updated successfully')

    } catch (error) {
      console.error('Failed to update platform file:', error)
      throw error
    }
  }

  /**
   * Generate Netlify URLs for new programs
   */
  generateNetlifyUrl(programType: string, programName: string): string {
    const sanitizedName = programName.toLowerCase().replace(/[^a-z0-9]/g, '-')
    return `https://alot1z-${programType}.netlify.app/${sanitizedName}`
  }

  /**
   * Update Alot1z.github.io launcher automatically
   */
  async updateGitHubPagesLauncher(): Promise<void> {
    if (!this.platformConfig) return

    try {
      // Generate launcher HTML with new programs
      const launcherContent = this.generateLauncherHTML()

      // Update launcher using git-mcp
      if (this.config.enableGitMcp) {
        await this.updateFileWithGitMcp('alo1z-github-io/index.html', launcherContent)
        
        // Also update the platform.txt in launcher
        const simplePlatformContent = this.generateSimplePlatformContent()
        await this.updateFileWithGitMcp('alo1z-github-io/platform.txt', simplePlatformContent)
      }

      console.log('GitHub Pages launcher updated')

    } catch (error) {
      console.error('Failed to update GitHub Pages launcher:', error)
    }
  }

  /**
   * Process queued updates in batch (free tier optimization)
   */
  async processUpdateQueue(): Promise<void> {
    if (this.updateQueue.length === 0) return

    try {
      // Add all queued entries to platform config
      if (this.platformConfig) {
        this.platformConfig.entries.push(...this.updateQueue)
        this.platformConfig.metadata.totalEntries = this.platformConfig.entries.length
        this.platformConfig.metadata.lastUpdate = Date.now()
      }

      // Clear queue
      this.updateQueue = []

      // Update platform file
      await this.updatePlatformFile()

      // Update GitHub Pages launcher
      await this.updateGitHubPagesLauncher()

      console.log('Processed update queue successfully')

    } catch (error) {
      console.error('Failed to process update queue:', error)
    }
  }

  /**
   * Get platform statistics
   */
  getStats(): {
    totalPrograms: number
    activePrograms: number
    queuedUpdates: number
    lastUpdate: number
    autoUpdateEnabled: boolean
  } {
    return {
      totalPrograms: this.platformConfig?.entries.length || 0,
      activePrograms: this.platformConfig?.entries.filter(e => e.status === 'active').length || 0,
      queuedUpdates: this.updateQueue.length,
      lastUpdate: this.platformConfig?.metadata.lastUpdate || 0,
      autoUpdateEnabled: this.config.enableGitMcp
    }
  }

  // Private methods

  private async loadPlatformConfig(): Promise<void> {
    try {
      // In real implementation, would load from platform.txt
      this.platformConfig = {
        version: '2.0.0',
        baseUrl: 'https://mose.windsurf.build',
        fallbackUrl: 'https://alot1z.github.io',
        entries: [
          {
            id: 'hub-ui',
            name: 'Hub UI',
            url: 'https://alot1z-hub-ui.netlify.app',
            type: 'hub-ui',
            description: 'Main platform interface and router',
            status: 'active',
            features: ['Navigation', 'Security', 'Iframe Management'],
            lastUpdated: Date.now(),
            autoGenerated: false
          },
          {
            id: 'ipa-builder',
            name: 'IPA Builder',
            url: 'https://alot1z-ipa-builder.netlify.app',
            type: 'ipa-builder',
            description: 'iOS IPA builder with TrollStore support',
            status: 'active',
            features: ['iOS Building', 'TrollStore', 'Code Signing'],
            lastUpdated: Date.now(),
            autoGenerated: false
          },
          {
            id: 'printer-builder',
            name: '3D Printer Builder',
            url: 'https://alot1z-printer-builder.netlify.app',
            type: 'printer-builder',
            description: '3D printer model generator',
            status: 'active',
            features: ['3D Modeling', 'STL Export', 'Parametric Design'],
            lastUpdated: Date.now(),
            autoGenerated: false
          },
          {
            id: 'game-builder',
            name: 'Game Builder',
            url: 'https://alot1z-game-builder.netlify.app',
            type: 'game-builder',
            description: 'Game development platform',
            status: 'active',
            features: ['Unity Integration', 'Asset Management', 'Publishing'],
            lastUpdated: Date.now(),
            autoGenerated: false
          },
          {
            id: 'ai-models',
            name: 'AI Models',
            url: 'https://alot1z-ai-models.netlify.app',
            type: 'ai-models',
            description: 'AI model router and prompt engine',
            status: 'active',
            features: ['Model Management', 'Local Inference', 'Custom Qodo Gen'],
            lastUpdated: Date.now(),
            autoGenerated: false
          }
        ],
        metadata: {
          totalEntries: 5,
          lastUpdate: Date.now(),
          autoUpdateEnabled: true,
          gitMcpEnabled: this.config.enableGitMcp
        }
      }

    } catch (error) {
      console.error('Failed to load platform config:', error)
      // Initialize with empty config
      this.platformConfig = {
        version: '2.0.0',
        baseUrl: 'https://mose.windsurf.build',
        fallbackUrl: 'https://alot1z.github.io',
        entries: [],
        metadata: {
          totalEntries: 0,
          lastUpdate: Date.now(),
          autoUpdateEnabled: true,
          gitMcpEnabled: this.config.enableGitMcp
        }
      }
    }
  }

  private async setupFileWatching(): Promise<void> {
    // In real implementation, would setup file system watching
    console.log('File watching setup for directories:', this.config.watchDirectories)
  }

  private startUpdateTimer(): void {
    if (this.updateTimer) return

    this.updateTimer = setInterval(async () => {
      try {
        // Scan for new programs
        const newPrograms = await this.scanForNewPrograms()
        
        if (newPrograms.length > 0) {
          console.log(`Found ${newPrograms.length} new programs`)
          this.updateQueue.push(...newPrograms)
        }

        // Process queue if in free tier mode
        if (this.config.freetierOptimized && this.updateQueue.length > 0) {
          await this.processUpdateQueue()
        }

      } catch (error) {
        console.error('Update timer error:', error)
      }
    }, this.config.updateInterval)
  }

  private async scanDirectory(directory: string): Promise<PlatformEntry[]> {
    const programs: PlatformEntry[] = []

    try {
      // In real implementation, would scan filesystem for new components/services
      // For now, simulate finding new programs
      
      // This would use git-mcp to scan for new files and detect patterns
      console.log(`Scanning directory: ${directory}`)

    } catch (error) {
      console.error(`Failed to scan directory ${directory}:`, error)
    }

    return programs
  }

  private generateEntryId(name: string): string {
    return name.toLowerCase().replace(/[^a-z0-9]/g, '-')
  }

  private generatePlatformContent(): string {
    if (!this.platformConfig) return ''

    const lines: string[] = []
    
    // Add header
    lines.push('# Multi-Hub Platform Configuration')
    lines.push(`# Version: ${this.platformConfig.version}`)
    lines.push(`# Last Updated: ${new Date(this.platformConfig.metadata.lastUpdate).toISOString()}`)
    lines.push(`# Total Entries: ${this.platformConfig.metadata.totalEntries}`)
    lines.push('')

    // Add base URLs
    lines.push(`BASE_URL=${this.platformConfig.baseUrl}`)
    lines.push(`FALLBACK_URL=${this.platformConfig.fallbackUrl}`)
    lines.push('')

    // Add entries
    for (const entry of this.platformConfig.entries) {
      lines.push(`# ${entry.name} - ${entry.description}`)
      lines.push(`${entry.id.toUpperCase()}_URL=${entry.url}`)
      lines.push(`${entry.id.toUpperCase()}_STATUS=${entry.status}`)
      lines.push(`${entry.id.toUpperCase()}_TYPE=${entry.type}`)
      if (entry.autoGenerated) {
        lines.push(`${entry.id.toUpperCase()}_AUTO_GENERATED=true`)
      }
      lines.push('')
    }

    return lines.join('\n')
  }

  private generateSimplePlatformContent(): string {
    if (!this.platformConfig) return ''

    const lines: string[] = []
    
    // Only base URLs for security (GitHub Pages launcher)
    lines.push('# Multi-Hub Platform - Public Launcher Configuration')
    lines.push(`BASE_URL=${this.platformConfig.baseUrl}`)
    lines.push(`FALLBACK_URL=${this.platformConfig.fallbackUrl}`)
    lines.push('')
    
    // Only base URLs for each service (security)
    for (const entry of this.platformConfig.entries) {
      const baseUrl = new URL(entry.url).origin
      lines.push(`${entry.id.toUpperCase()}_BASE=${baseUrl}`)
    }

    return lines.join('\n')
  }

  private generateLauncherHTML(): string {
    if (!this.platformConfig) return ''

    return `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multi-Hub Platform Launcher</title>
    <style>
        body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #1e3a8a 0%, #3b82f6 100%);
            margin: 0; padding: 20px; color: white; min-height: 100vh;
        }
        .container { max-width: 1200px; margin: 0 auto; }
        .header { text-align: center; margin-bottom: 40px; }
        .grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px; }
        .card { 
            background: rgba(255,255,255,0.1); backdrop-filter: blur(10px);
            border-radius: 12px; padding: 24px; border: 1px solid rgba(255,255,255,0.2);
            transition: transform 0.2s, box-shadow 0.2s;
        }
        .card:hover { transform: translateY(-4px); box-shadow: 0 8px 32px rgba(0,0,0,0.3); }
        .card h3 { margin: 0 0 12px 0; font-size: 1.5em; }
        .card p { margin: 0 0 16px 0; opacity: 0.9; }
        .features { display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 16px; }
        .feature { 
            background: rgba(255,255,255,0.2); padding: 4px 8px; 
            border-radius: 16px; font-size: 0.8em;
        }
        .btn { 
            background: #3b82f6; color: white; padding: 12px 24px; 
            border: none; border-radius: 8px; cursor: pointer; width: 100%;
            font-size: 1em; transition: background 0.2s;
        }
        .btn:hover { background: #2563eb; }
        .status { 
            display: inline-block; padding: 4px 8px; border-radius: 12px; 
            font-size: 0.8em; margin-bottom: 12px;
        }
        .status.active { background: #10b981; }
        .status.beta { background: #f59e0b; }
        .auto-generated { opacity: 0.8; font-style: italic; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🚀 Multi-Hub Platform</h1>
            <p>AI-Powered Development Platform - Free Tier, No Limits</p>
            <p><small>Last Updated: ${new Date(this.platformConfig.metadata.lastUpdate).toLocaleString()}</small></p>
        </div>
        
        <div class="grid">
            ${this.platformConfig.entries.map(entry => `
                <div class="card ${entry.autoGenerated ? 'auto-generated' : ''}">
                    <div class="status ${entry.status}">${entry.status}</div>
                    <h3>${entry.name}</h3>
                    <p>${entry.description}</p>
                    <div class="features">
                        ${entry.features.map(feature => `<span class="feature">${feature}</span>`).join('')}
                    </div>
                    ${entry.autoGenerated ? '<p><small>🤖 Auto-generated by Custom Qodo Gen</small></p>' : ''}
                    <button class="btn" onclick="openApp('${entry.url}')">
                        Launch ${entry.name}
                    </button>
                </div>
            `).join('')}
        </div>
    </div>

    <script>
        function openApp(url) {
            // Security check - validate URL against platform.txt
            if (url.includes('alot1z') || url.includes('mose.windsurf.build')) {
                window.open(url, '_blank');
            } else {
                alert('Security: Unauthorized URL blocked');
            }
        }
        
        // Auto-refresh every 5 minutes to get latest updates
        setTimeout(() => location.reload(), 300000);
    </script>
</body>
</html>`
  }

  private async updateFileWithGitMcp(filePath: string, content: string): Promise<void> {
    // In real implementation, would use git-mcp to update files
    console.log(`Updating file with git-mcp: ${filePath}`)
    console.log('Content length:', content.length)
  }

  private async commitChanges(message: string): Promise<void> {
    // In real implementation, would use git-mcp to commit
    console.log(`Committing changes: ${message}`)
  }

  private async triggerDeployment(): Promise<void> {
    // In real implementation, would trigger GitHub Actions or Netlify deployment
    console.log('Triggering automatic deployment')
  }

  /**
   * Cleanup resources
   */
  async destroy(): Promise<void> {
    if (this.updateTimer) {
      clearInterval(this.updateTimer)
      this.updateTimer = null
    }
    
    this.watchedFiles.clear()
    this.updateQueue = []
    this.isInitialized = false
    
    console.log('Platform Auto Updater destroyed')
  }
}

// Singleton instance
let globalPlatformUpdater: PlatformAutoUpdaterService | null = null

export const getPlatformAutoUpdaterService = (config?: Partial<AutoUpdateConfig>): PlatformAutoUpdaterService => {
  if (!globalPlatformUpdater) {
    globalPlatformUpdater = new PlatformAutoUpdaterService(config)
  }
  return globalPlatformUpdater
}

export default PlatformAutoUpdaterService